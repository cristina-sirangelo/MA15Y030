---
title: "BD xxx : Normalisation I"
---

```{.r}
#| echo: false
#| eval: false
library(DBI)
db <- dbConnect(RSQLite::SQLite(), dbname = "sql.sqlite")
knitr::opts_chunk$set(connection = "db")
```


# Introduction  {background-color="#1c191c"}

---


## Conception du modèle relationnel

Une première approche pour concevoir un modèle relationnel (l'ensemble des schémas d'une bd) consiste à :

- Identifier les attributs d'intérêt

- Répartir les attributs dans plusieurs relations

--

- Comment savoir si le modèle relationnel est *bon* ?

- Si ce n'est pas le cas : y a-t-il des techniques pour le transformer en un *bon* modèle?




---



## Qualité d'un schéma

Quelles sont de *bonnes propriétés* d'un schéma ?


**Exemple**

Attributs relatifs à des *vendeurs*, *produits* et *livraisons*

| Attribut |  Usage |
|:---------:|----------------|
|.red[`V#`] :| numéro du vendeur   |
|`Vnom` : | nom du vendeur  |
|`Vville` : |ville du vendeur   |
|.red[`P#`] : |numéro du produit  |
|`Pnom` : |nom du produit  |
|`Pville` : |ville où le produit est stocké  |
|`Qte` : |quantité de produit livrée au vendeur |

---



## Qualité d'un schéma

Un schéma relationnel possible : une seule relation `R` avec tous les attributs

```
R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)
```

--


- {{< fa face-frown >}} C'est une mauvaise modélisation.

- {{< fa brain >}} Pourquoi ?



---

## Qualité d'un schéma relationnel

- **Redondance**

| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte |
|---:|:-----:|:-------:|----:|:-----:|:-------:|----: |
|3 | MagicV | Paris | ... | ... | ... | ... |
|3 | MagicV | Paris | ... | ... | ... | ... |
|2 | IdealB | Lyon | ... | ... | ... | ... |
|2 | IdealB | Lyon | ... | ... | ... | ... |


`Vnom` et `Vville` sont déterminés par` V#` :

si deux livraisons ont le même `V#`, elles ont aussi le même `Vville` et le même `Vnom`

---

## {{< fa face-frown >}}


- **Anomalies de mise à jour**

`Vnom` ou `Vville` pourrait être mis à jour dans une livraison et pas dans une autre, ce qui donnerait une incohérence. Pour éviter cela, la mise à jour est coûteuse

- **Anomalies d'insertion**

On ne peut pas enregistrer un vendeur s'il ne reçoit pas de livraison

- **Anomalies de suppression**

Si on supprime toutes les livraisons à un vendeur, on perd toute l'information sur ce vendeur


---

## Qualité d'un schéma relationnel

- Un *bon* schéma

```{verbatim}
Vendeur(V#, Vnom, Vville)    Clef : V#
Produit(P#, Pnom, Pville)    Clef : P#
Livraison(V#, P#, Qte)       Clef : (V#,P#)
```

- Plus d'anomalie ! Comment y arriver?

--

La théorie de la *normalisation* des BD relationnelles fournit

- la notion de *forme normale* : propriétés d'un schéma qui garantissent l'absence de redondance et des anomalies qui en dérivent. Ces propriétés sont définies par rapport à un ensemble de *contraintes*

- des *techniques de normalisation* : passage d'un schéma arbitraire (mauvais) à un schéma en forme normale (obtenu typiquement par décomposition)


---


## Dépendances fonctionnelles


Une dépendance fonctionnelle est une forme particulière de .red[contrainte d'intégrité] portant sur une relation/table : il s'agit
d'une forme particulière contrainte d'exclusion `EXCLUDE`

C'est la *réalité* modélisée qui impose ces contraintes

--

Exemple :

```
R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)
```

Un ensemble de dépendances fonctionnelles qu'on peut raisonnablement supposer :

```{verbatim}
V# ⟶ Vnom Vville
P# ⟶ Pnom Pville
V# P# ⟶ Qte
```


- Cela signifie que l'on ne considère que des relations R qui satisfont :
- si 2 tuples de `R` ont la même valeur de `V#` alors ils ont la même valeur de `Vnom` et `Vville`
- si 2 tuples de `R` ont la même valeur de `P#` alors ils ont la même valeur de `Pnom` et `Pville`
- ...



---



## DF exemple




| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte  |
|---:|:-----:|:-------:|----:|:-----:|:-------:|:-----:|
|3 | MagicV | Paris | 322 | manteau | Lille | 2 |
|1 | StarV | Rome | 546 | veste | Rome | 1 |
|3 | MagicV | Paris | 322 | manteau | Lille | 5 |
|2 | IdealB | Lyon | 145 | jupe | Paris | 7 |
|2 | IdealB | Lyon | 234 | jupe | Lille | 1 |



--

- `R` satisfait `V#` ⟶ `Vnom Vville` et `P#` ⟶ `Pnom Pville`

- `R` viole `V# P#` ⟶ `Qte`


---



## Exemple

Schéma `Films(titre, année, durée, genre, producteur, acteur)`



| titre |  année |  durée |  genre |  producteur |  acteur |
|:------|:----------|----------:|:----------|:---------------|:-----------|
|Star Wars | 1977 | 124 | SciFi | Fox | Carrie Fisher |
|Star Wars | 1977 | 124 | SciFi | Fox | Mark Hamill |
| Star Wars | 1977 | 124 | SciFi | Fox | Harrison Ford |
|Gone With The Wind | 1939 | 231 | drame | MGM | Vivien Leigh|
|Wayne's World | 1992 | 95 | comédie | Paramount | Dana Carvey|
|Wayne's World | 1992 | 95 | comédie | Paramount | Mike Meyers|


- On sait qu'il n'y a pas 2 films de même nom qui sortent la même année. On a donc la dépendance suivante

`titre, année` ⟶ `durée, genre, producteur`

- La DF

`titre, année` ⟶ `acteur`

est certainement fausse puisqu'un film fait intervenir en général plusieurs acteurs

- A-t-on la DF

`titre, acteur` ⟶ `année, durée, genre, producteur` ?


---




## Définition d'une dépendance fonctionnelle

- Soit $\mathcal{A}$ un schéma de relation ($\mathcal{A}$ est un ensemble d'attributs)

- Une *dépendance fonctionnelle* sur $\mathcal{A}$ est une expression de la forme

$$X \rightarrow Y$$

où $X\subset \mathcal{A}$ et $Y\subset \mathcal{A}$

- Une relation $R$ de schéma $\mathcal{A}$ satisfait $X \rightarrow Y$
si pour tous tuples $s,t \in R$ on a

$$\bigl(\forall A\in X\ s.A=t.A\bigr) \Longrightarrow \bigl(\forall A\in Y\ s.A=t.A\bigr)$$

(si $s$ et $t$ coïncident sur $X$ alors $s$ et $t$ coïncident sur $Y$)

- Une relation $R$, de schéma $\mathcal{A}$, satisfait un ensemble $\Sigma$ de DF si $R$ satisfait chaque DF de $\Sigma$


---




## Exemples et dépendance élémentaire

Exemple

Dans la base **Sakila**, relation `Actor` :

- `Actor_id` ⟶ `last_name`, `first_name`

- car `Actor_id` est une clé...


---


#### Définition (dépendance élémentaire)

$A_1,...,A_p \rightarrow Y$ est une dépendance élémentaire si
pour tout $j\leq p$ :  $A_1,...,A_{j-1},A_{j+1},...,A_p\not\rightarrow Y$


- `No_insee` ⟶ `sexe, mois_naiss, jour_naiss` est  élémentaire.

- `No_insee, jour_naiss` ⟶ `sexe, mois_naiss, ville_naiss` n'est pas élémentaire ...

.fr[`No_insee` suffit.]



---



## Dépendance fonctionnelle triviale

Une DF triviale est une DF satisfaite par toute relation

#### Définition (dépendance triviale)

Soient $X,Y\subset \mathcal{A}$

- $X\rightarrow Y$ est une dépendance triviale si $Y \subset X$


#### Exemple

- `No_insee ` ⟶ `No_insee` est  triviale



---



## Implication pour les  DF

- Soit $\mathcal{A}$ un schéma de relation ( $\mathcal{A}$ est un ensemble d'attributs) et $\Sigma$
un ensemble de DF sur $\mathcal{A}$

- Exemple : $\mathcal{A}=\{A,B,C\}$ et $\Sigma=\{A\rightarrow B, B\rightarrow C\}$

- Les DF données impliquent d'autres DF additionnelles

--

- Exemple : $A\rightarrow B$ et $B\rightarrow C$ impliquent $A\rightarrow C$

c'est-à-dire :
toute relation de schéma $\mathcal{A}$ qui satisfait $A\rightarrow B$ et $B\rightarrow C$
satisfait également $A\rightarrow C$

--

- Autre exemple :

$A\rightarrow C$, $BC\rightarrow D$, $AD\rightarrow E$ impliquent $AB\rightarrow E$


---



## Implication  DF

#### Définition

Un ensemble $\Sigma$ de DF implique une autre DF $X\rightarrow Y$ si
toute relation qui satisfait $\Sigma$ satisfait également $X\rightarrow Y$.

Notation

pour $\Sigma$ implique $X\rightarrow Y$ : $\Sigma \models X \rightarrow Y$

Exemple

$\Sigma=\{A\rightarrow B, B\rightarrow C\}$ implique

$A\rightarrow B$, $B\rightarrow C$, $A\rightarrow C$, $A,B\rightarrow C$, ...

mais aussi les DF triviales $A\rightarrow A$, $AB\rightarrow A$, ...


---



## Règles d'Armstrong

Trois règles d'inférence (facile à vérifier) :

- Transitivité : $\{ X\rightarrow Y, Y\rightarrow Z\} \models X\rightarrow Z$

- Augmentation : $X\rightarrow Y \models \{X,Z\} \rightarrow \{Y,Z\}$

- Réflexivité : $\varnothing \models \{X,Y\}\rightarrow X$  (DF triviale)

---

## Théorème

$\Sigma \models X\rightarrow Y$

si et seulement si

$X\rightarrow Y$ peut-être dérivée de $\Sigma$ par applications successives des trois règles d'Armstrong

---

De ces 3 règles, on déduit d'autres règles :

- Union : $\{X\rightarrow Y, X\rightarrow Z\} \models X\rightarrow \{Y,Z\}$

- Séparation : $X\rightarrow \{Y,Z\} \models X\rightarrow Y$

- ...


---



## Clef et super-clef

Soit $\mathcal{A}$ un schéma et $\Sigma$ une ensemble de DF sur $\mathcal{A}$

#### Définition

Un ensemble d'attributs $X$ est une *super-clef* si

$\Sigma \models X \rightarrow \mathcal{A}$

c-à-d si $X$ détermine tous les attributs de $\mathcal{A}$

--

#### Définition

Un ensemble d'attributs $X$ est une **clef** si $X$ est une super-clef et si
tout sous-ensemble $Y\subset X$ tel que $Y\not=X$ n'est pas une super-clef


--

Exemple

$R(A,B,C) \qquad \Sigma=\{A\rightarrow B, B\rightarrow C\}$

Super-clefs : $A$, $AB$, $AC$, $ABC$

Clef : $A$ (la seule)


---

## Implication d'un ensemble de DF par un autre

Soit $\Sigma$ et $\Sigma'$ deux ensemble de DF sur un schéma $\mathcal{A}$

On dit que $\Sigma$ *implique* $\Sigma'$  si $\Sigma$ implique toutes les DF de $\Sigma'$

On le note $\Sigma \models \Sigma'$

---

## Exemples


$\mathcal{A}=\{A,B,C,D\}$,

$\Sigma= \{AB\rightarrow C, C\rightarrow A, BC\rightarrow D\}$|

$\Sigma'=\{AB\rightarrow D\}$

$\Sigma\models\Sigma'$


---

## Définition


$\Sigma$ est *équivalent* à $\Sigma'$

ssi

$\Sigma\models\Sigma'$ et $\Sigma'\models\Sigma$


--

Exemples

- $X\rightarrow A_1,...,A_n$ est équivalent à $X\rightarrow A_1$, ..., $X\rightarrow A_n$|

- $XY\rightarrow YZ$ est équivalent à $XY\rightarrow Z$





---





# Fermeture d'un ensemble d'attributs

---


## Question principale

- Comment vérifier si un ensemble $\Sigma$ de DF implique une DF $X\rightarrow Y$~?

- Par les équivalences présentées précédemment, la question se ramène à :

Comment vérifier si un ensemble $\Sigma$ de DF implique une DF $X\rightarrow A$
où $A$ est un attribut~?



---



## Fermeture d'un ensemble d'attributs

Soit $X \subset\mathcal{A}$ un sous-ensemble d'attributs et $\Sigma$ un ensemble de DF sur $\mathcal{A}$

#### Définition

La fermeture de $X$ par rapport à $\Sigma$ est

$$X^+=\{ A\in\mathcal{A} \mid \Sigma\models X\rightarrow A \}$$

Autrement dit $X^+$ est l'ensemble des attributs déterminés par $X$

--

Exemple

- $R(ABCDE)$
- $\Sigma=\{AB\rightarrow C, C\rightarrow D, E\rightarrow D\}$
- $\{A,B\}^+=\{A,B,C,D\}$


---



## Algorithme pour calculer une fermeture

Soit $\Sigma$ un ensemble de DF sur un schéma $\mathcal{A}$ et $X\subset\mathcal{A}$

#### Algorithme


```{verbatim, lang="r"}
Xc <-  X

while (exists Y -> Z in Σ with Y ⊂ Xc and not Z ⊄ Xc) {
  Xc <- Xc ∪ Z
}

return Xc
```

--

- `Xc` grandit à chaque itération

Comme $\mathcal{A}$ est fini, l'algorithme se termine en au plus $|\mathcal{A}|$ itérations


---



## Exemple de calcul de fermeture

$\mathcal{A}=\{ABCDEF\}$ $\Sigma=\{A\rightarrow C, BC\rightarrow D, AD\rightarrow E\}$ $X=\{A,B\}$

- $X_c=\{A,B\}$

- $A\rightarrow C$ donc on obtient $X_c=\{A,B,C\}$

- $BC\rightarrow D$ donc on obtient $X_c=\{A,B,C,D\}$

- $AD\rightarrow E$ donc on obtient $X_c=\{A,B,C,D, E\}$

- On obtient $X^+=\{A,B,C,D, E\}$



---




## Correction de l'algorithme de fermeture

- L'algorithme calcule uniquement des attributs dans la fermeture car
on a toujours $X_c\subset X^+$

- L'algorithme calcule tous les attributs dans la fermeture:  $X_c=X^+$ quand l'algorithme se termine

---


**Preuve** :

Supposons que $A\notin X_c$ quand l'algorithme se termine

La relation $R=\{t_1,t_2\}$ suivante (où $c\neq d$ )


|       | $X_c$   | A |  ...| ... |
|:------|:-------:|:----:|:------:|
| $t_1$ | aa... a | c | cc... c |
| $t_2$ | aa... a | d | dd... d |

satisfait $\Sigma$

car pour toute DF $Y\rightarrow Z$ telle que $Y\subset X_c$ on a $Z\subset X_c$.

Mais $R$ ne satisfait pas $X\rightarrow A$. Donc $A\notin X^+$.



---



## Calcul de la fermeture transitive : exemple

::: {.columns}
::: {.column}

Soit $R$ d'ensemble d'attributs

$$\mathcal{A} =\{A,B,C,D,E,F,G\}$$

Soit $X=\{B,D\} \subset \mathcal{A}$

Et $Σ$ l'ensemble de dépendances fonctionnelles ci-contre

:::
::: {.column}

|   $\Sigma$   |
|:---------------------:|
| $A,B \rightarrow C$ |
| $C \rightarrow A$ |
| $B,C \rightarrow D$ |
| $A,C,D \rightarrow B$ |
| $F\rightarrow A,C$|
| $D \rightarrow E,G$ |
| $B,E \rightarrow C$ |
| $C,G \rightarrow B,D$ |
| $C,E \rightarrow A,G$ |

:::
::: <!-- end columns -->


Montrer que  $X^+=\{A,B,C,D,E,G\}$

Donner une clef de $R$



---


# Forme normale de Boyce-Codd


---


## Forme normale de Boyce-Codd (FNBC)

#### Définition

Un schéma $\mathcal{A}$ est en FNBC par rapport à un ensemble de dépendances fonctionnelles $\Sigma$ sur $\mathcal{A}$

si

pour toute DF $X\rightarrow Y$ impliquée par $\Sigma$ avec $Y\not\subset X$, $X$ est une super-clef

--

- {{< fa hand-point-right >}} $(\mathcal{A},\Sigma)$ est en FNBC si pour toute DF non triviale impliquée par $\Sigma$, le membre de gauche est une super-clef

---

#### Proposition

Soit $\Sigma'$ un ensemble de DF équivalent à $\Sigma$.

$(\mathcal{A},\Sigma)$ est en FNBC si et seulement si pour toute DF non triviale de $\Sigma'$, le membre de gauche est une super-clef


En effet  toute DF impliquée par $\Sigma$ peut être obtenue à partir des DF de $\Sigma'$ en utilisant les règles d'Armstrong


---



## FNBC : exemple 1

- Schéma $\mathcal{A}=\{\text{V#, Vnom, Vville, P#, Pnom, Pville, Qte}\}$

Ensemble de dépendances fonctionnelles $\Sigma$ :

```{verbatim}
V# ⟶ Vnom Vville
P# ⟶ Pnom Pville
V# P# ⟶ Qte
```

--

$\mathcal{A}$ n'est pas en FNBC par rapport $\Sigma$.

En effet ni V# ni P# ne sont des super-clefs


---



## FNBC : exemple 2

Schéma `Films(titre, année, durée, genre, producteur, acteur)`


- On a la dépendance suivante `titre, année ⟶ durée, genre, producteur`

- `titre, année, acteur` est la seule clef

- La DF  `titre, année` ⟶ `durée, genre, producteur`} viole la condition de FNBC


---



## FNBC : exemple 3


Trois schémas en FNBC :

| Relation | Clef |
|:---------|:------:|
| `Vendeur(V#, Vnom, Vville)` |  `V#`  |
| `Produit(P#, Pnom, Pville)` |  `P#`  |
| `Livraison(V#, P#, Qte)`    | `(V#,P#)` |


---



## Schéma avec deux attributs


#### Proposition

Soit $\mathcal{A}=\{A,B\}$ un schéma avec deux attributs et $\Sigma$ un ensemble de DF non triviales.

$\mathcal{A}$ est toujours en FNBC par rapport à $\Sigma$

--

**Preuve** :

On distingue 4 cas

- $\Sigma=\emptyset$
- $\Sigma=\{A\rightarrow B\}$
- $\Sigma=\{B\rightarrow A\}$
- $\Sigma=\{A\rightarrow B, B\rightarrow A\}$




---

# Décomposition d'une relation

---


## Décomposition d'un schéma de relation

Soit $\mathcal{A}$ un schéma de relation

Un décomposition de $\mathcal{A}$ est un ensemble $\{\mathcal{A}_1,..., \mathcal{A}_k\}$
de sous-ensembles de $\mathcal{A}$ tel que

$$\mathcal{A}_i\not=\emptyset, 1\le i\le k, \quad \text{ et } \quad \mathcal{A} = \bigcup_{i=1}^k \mathcal{A}_i$$

---

## Exemple

```
Vendeur(V#, Vnom, Vville)
Produit(P#, Pnom, Pville)
Livraison(V#, P#, Qte)
```

est une décomposition du schéma

`R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)`


---

## Exemple de décomposition


Schéma :

`Films(titre, année, durée, genre, producteur, acteur)`

Une décomposition :

`Films1(titre, année, durée, genre, producteur)`

`Films2(titre, année, acteur)`

- `Films1` est FNBC par rapport à $\Sigma_1=\{\texttt{titre, année ⟶ durée, genre, producteur}\}$
- `Films2` est en FNBC par rapport à $\Sigma_2=\emptyset$


---

## Propriétés d'une décomposition

On ne peut pas décomposer arbitrairement,

Toutes les décompositions ne sont pas intéressantes

--

#### Conditions pour une décomposition *raisonnable* :

- Décomposition .red[sans perte d'information]

- Décomposition *sans perte de dépendance fonctionnelle*





---

# Décomposition sans perte d'information

---


## Décomposition sans perte d'information


Idée : Si on remplace le schéma

`(V#, Vnom, Vville, P#, Pnom, Pville, Qte)`

par les trois schémas

```
Vendeur(V#, Vnom, Vville)
Produit(P#, Pnom, Pville)
Livraison(V#, P#, Qte)
```

alors au lieu de stocker une relation `R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)`, on stockera
ses projections

$$\pi_{\texttt{V#,Vnom,Vville}}(\texttt{R}) \qquad \pi_{\texttt{P#,Pnom,Pville}}(\texttt{R}) \quad \pi_{\texttt{V#,P#,Qte}}(\texttt{R})$$

{{< fa brain >}} Peut-on retrouver `R` à partir de ces trois projections ?



---



## Décomposition sans perte d'information

- La décomposition doit garantir que pour toute relation `R`, ses projections contiennent
la même information que `R` au sens que l'on doit pouvoir reconstruire `R` à partir de ses projections

- Comment tenter de reconstruire `R` à partir de ses projections ?

On considère la *jointure naturelle*

$$\pi_{\texttt{V#,Vnom,Vville}}(\texttt{R}) \bowtie \pi_{\texttt{P#,Pnom,Pville}}(\texttt{R}) \bowtie \pi_{\texttt{V#,P#,Qte}}(\texttt{R})$$



---



## Décomposition sans perte d'information

La propriété souhaitée s'écrit donc

$$R = \pi_{\texttt{V#,Vnom,Vville}}(\texttt{R}) \bowtie \pi_{\texttt{P#,Pnom,Pville}}(\texttt{R}) \bowtie \pi_{\texttt{V#,P#,Qte}}(\texttt{R})$$

pour toute relation `R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)` satisfaisant les DF

- Est ce vrai?

- Intuitivement, oui : à partir d'un tuple de `Livraison(V#,P#,Qte)`

- `V#` permet de récupérer toutes les informations sur le vendeur `(V# ⟶ Vnom Vville)`

- `P#` permet de récupérer toutes les informations sur le produit `(P# ⟶ Pnom Pville)`

- .red[La propriété d'être sans perte d'information est liée à l'ensemble de DF considéré]


---



## Décomposition sans perte d'information (lossless join)

#### **Définition**

Soit $\mathcal{A}$ un schéma de relation et $\Sigma$ un ensemble de DF sur $\mathcal{A}$.

Une décomposition $\{\mathcal{A}_1,..., \mathcal{A}_k\}$ est sans perte d'information par rapport à $\Sigma$
si pour toute relation $R$  de schéma $\mathcal{A}$ satisfaisant $\Sigma$ on a

$$R= \pi_{\mathcal{A}_1}(R) \bowtie \pi_{\mathcal{A}_2}(R) \bowtie...\bowtie\pi_{\mathcal{A}_k}(R)$$


---



## Exemple de décomposition avec perte d'information

$\mathcal{A}=\{A,B,C\} \quad  \Sigma=\{AB\rightarrow C\}$

Décomposition $\mathcal{A}_1=\{A,B\}  \quad  \mathcal{A}_2=\{B,C\}$

.fl.w-30.pa2[
Soit $R$ la relation

| A   |  B  |  C  |
|:---:|:---:|:---:|
|1 | 2 | 3 |
|4 | 2 | 5 |
]
.fl.w-30.pa2[
$\pi_{AB}(R)=$

| A |  B |
|:---:|:---:|
| 1 | 2  |
| 4 | 2  |

]

.fl.w-30.pa2[
$\pi_{BC}(R)=$

| B |  C |
|:---:|:---:|
| 2 | 3  |
| 2 | 5  |

]

$\pi_{AB}(R) \bowtie \pi_{BC}(R)=$

| A   |  B  |  C  |
|:---:|:---:|:---:|
|   1 | 2   | 3   |
|   4 | 2   | 5   |
| .red[1] | .red[2] | .red[5] |
| .red[4] | .red[2] | .red[3] |




---

# Algorithme de poursuite

---


## Algorithme de poursuite

- Comment déterminer si une décomposition est sans perte d'information?

- Si $R$ est une relation de schéma $\mathcal{A}$ on a toujours que

$$R\subset \pi_{\mathcal{A}_1}(R) \bowtie \pi_{\mathcal{A}_2}(R) \bowtie...\bowtie\pi_{\mathcal{A}_k}(R)$$

par définition de la jointure naturelle et de la projection

- Le seul problème est que les jointures peut générer des tuples supplémentaires
- Mais comme $R$ est supposée vérifier les DF de $\Sigma$, l'inclusion inverse est garantie dans certains cas
- Pour le savoir, un algorithme simple existe appelé algorithme de poursuite



---



## Algorithme de poursuite : exemple


Si on remplace le schéma `(V#, Vnom, Vville, P#, Pnom, Pville, Qte)`
par

```
Vendeur(V#, Vnom, Vville)}
Produit(P#, Pnom, Pville)}
Livraison(V#, P#, Qte)
```

A-t-on

$$\pi_{\texttt{V#,Vnom,Vville}}(\texttt{R}) \bowtie \pi_{\texttt{P#,Pnom,Pville}}(\texttt{R}) \bowtie \pi_{\texttt{V#,P#,Qte}}(R) \subset \texttt{R} \quad ?$$

???


Soit $t$ un tuple dans la jointure


| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte |
|:--:|:------|:------|:---:|:------|:------|:------|
| $a$ | $b$ | $c$ | $d$ | $e$ | $f$ | $g$ |



---



## Algorithme de poursuite : exemple


Soit $t$ un tuple dans la jointure

| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte |
|:--:|:------|:------|:---:|:------|:------|:------|
| $a$ | $b$ | $c$ | $d$ | $e$ | $f$ | $g$ |


- $(a, b, c)\in \pi_{\texttt{V#,Vnom,Vville}}(\texttt{R})$ donc
il existe $e_1, f_1, g_1$ tels que  $(a, b, c, d_1, e_1, f_1, g_1) \in \texttt{R}$

- $(d,e,f) \in \pi_{\texttt{P#,Pnom,Pville}}(\texttt{R})$ donc il existe $a_2, b_2, c_2, g_2$ tels que
$(a_2, b_2, c_2, d, e, f, g_2)\in \texttt{R}$

- $(a,d,g)\in \pi_{\texttt{V#,P#,Qte}}(R)$ donc il existe $b_3,c_3,e_3,f_3$ tels que
$(a,b_3,c_3,d,e_3,f_3,g)\in \texttt{R}$

- On peut le représenter comme ceci :

| `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pville` |  `Qte` |
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|Vendeur | .red[ $a$ ] | .red[ $b$ ] | .red[ $c$ ] | $d_1$ | $e_1$ | $f_1$ | $g_1$ |
|Produit | $a_2$ | $b_2$ | $c_2$ | .red[ $d$ ] | .red[ $e$ ] | .red[ $f$ ] | $g_2$ |
|Livraison | .red[ $a$ ] | $b_3$ | $c_3$ | .red[ $d$ ] | $e_3$ | $f_3$ | .red[ $g$ ] |


---



## Algorithme de poursuite : exemple


| `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pville` |  `Qte` |
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|Vendeur | .red[ $a$ ] | .red[ $b$ ] | .red[ $c$ ] | $d_1$ | $e_1$ | $f_1$ | $g_1$ |
|Produit | $a_2$ | $b_2$ | $c_2$ | .red[ $d$ ] | .red[ $e$ ] | .red[ $f$ ] | $g_2$ |
|Livraison | .red[ $a$ ] | $b_3$ | $c_3$ | .red[ $d$ ] | $e_3$ | $f_3$ | .red[ $g$ ] |



- `V#` ⟶ `Vnom`, `Vville` donc $b_3=b$ et $c_3=c$

| `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pville` |  `Qte` |
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|Vendeur | .red[ $a$ ] | .red[ $b$ ] | .red[ $c$ ] | $d_1$ | $e_1$ | $f_1$ | $g_1$ |
|Produit | $a_2$ | $b_2$ | $c_2$ | .red[ $d$ ] | .red[ $e$ ] | .red[ $f$ ] | $g_2$ |
|Livraison | .red[ $a$ ] | $b$ | $c$ | .red[ $d$ ] | $e_3$ | $f_3$ | .red[ $g$ ] |



---

## Algorithme de poursuite : exemple (suite)

- `P#⟶ Pnom, Pville` donc $e_3=e$ et $f_3=f$


| `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pville` |  `Qte` |
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|Vendeur | .red[ $a$ ] | .red[ $b$ ] | .red[ $c$ ] | $d_1$ | $e_1$ | $f_1$ | $g_1$ |
|Produit | $a_2$ | $b_2$ | $c_2$ | .red[ $d$ ] | .red[ $e$ ] | .red[ $f$ ] | $g_2$ |
|Livraison | .red[ $a$ ] | $b$ | $c$ | .red[ $d$ ] | $e$ | $f$ | .red[ $g$ ] |

- On a obtenu une ligne égale au tuple $t=(a,b,c,d,e,f,g)$ donc $t\in \texttt{R}$.

On en déduit que la décomposition est Sans Perte d'Information (SPI)

---



## Algorithme de poursuite : cas général

- **Entrée** : un schéma $\mathcal{A}$, une décomposition $\{\mathcal{A}_1,...,\mathcal{A}_k\}$ et un ensemble $\Sigma$ de DF

- Pour chaque attribut de $\mathcal{A}$, choisir un symbole (par exemple $a$, $b$, $c$,...). La correspondance doit être injective.

- Construire un tableau dont les colonnes sont les attributs de $\mathcal{A}$

Le tableau a une ligne pour chaque $\mathcal{A}_i$

Sur la ligne associée à $\mathcal{A}_i$, les positions correspondant à $\mathcal{A}_i$ sont remplies avec les symboles choisis.

Les autres positions sont remplies avec les symboles indicés par $i$

- Répéter tant que possible : s'il existe une DF $X\rightarrow Y$ dans $\Sigma$ et deux lignes du tableau
en accord sur $X$, égaliser ces deux lignes sur $Y$

- **Sortie** : Si on obtient une ligne sans valeur indicée, la décomposition est sans perte d'information, sinon il y a perte d'information

---

## Algorithme de poursuite : exemple 2

Considérons l'exemple : $\mathcal{A}=\{A,B,C,D\}$ avec $\mathcal{A}_1=\{A,B\}$, $\mathcal{A}_2=\{B,C\}$ et $\mathcal{A}_3=\{C,D\}$

Soit $\Sigma=\{{C}\rightarrow{D}; {B}\rightarrow{A}\}$.

Soit $t=(a,b,c,d)$. Soit $t_1,t_2,t_3$ les tuples de $R$ suivants:


|  | A | B | C | D  |
|:----|:----:|:----:|:----:|:----:|
| $t_2$ | $a_2$ | `b` | `c` | $d_2$  |
| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |

On a pris  $c_1,d_1, a_2,d_2, a_3,b_3$ comme valeurs variables et `a,b,c,d` comme constantes


---



## Algorithme de poursuite - exemple 2


|  | A | B | C | D  |
|:----|:----:|:----:|:----:|:----:|
| $t_1$ | `a` | `b` |  $c_1$| $d_1$  |
| $t_2$ | $a_2$ | `b` | `c` | $d_2$  |
| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |

Par la dépendance ${B}\rightarrow{A}$, il vient :


|  | A | B | C | D  |
|:----|:----:|:----:|:----:|:----:|
| $t_1$ | `a` | `b` |  $c_1$| $d_1$  |
| $t_2$ | .red[ `a` ] | `b` | `c` | $d_2$  |
| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |



---


## Algorithme de poursuite : exemple 2


Par la dépendance ${C}\rightarrow{D}$, il vient :

|  | A | B | C | D  |
|:----|:----:|:----:|:----:|:----:|
| $t_1$ | `a` | `b` |  $c_1$| $d_1$  |
| $t_2$ |  `a`  | `b` | `c` |  `d`   |
| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |

On a bien fait apparaître $t$ qui appartient donc à  $R$.

---



## Algorithme de poursuite - exemple 3

Considérons toujours l'exemple : $\mathcal{A}=\{A,B,C,D\}$ avec

$\mathcal{A}_1=\{A,B\}$, $\mathcal{A}_2=\{B,C\}$ et $\mathcal{A}_3=\{C,D\}$

Mais avec  $\Sigma=\{{B}\rightarrow{AD}\}$.




| A | B | C | D  |
|:---:|:---:|:---:|:---:|
| `a` | `b` |  $c_1$ | $d_1$  |
| $a_2$ | `b` | `c` | $d_2$  |
|  $a_3$ | $b_3$ | `c` | `d`  |



Dans ce cas, en utilisant la seule DF ${B}\rightarrow{AD}$, on obtient $a_2=a$ et $d_1=d_2$ :

| A | B | C | D  |
|:---:|:---:|:---:|:---:|
| `a` | `b` |  $c_1$ | $d_1$  |
| `a` | `b` | `c` | $d_1$  |
|  $a_3$ | $b_3$ | `c` | `d`  |


Mais on ne peut aller plus loin : la jointure des projections contient
des tuples qui ne sont pas dans la relation originelle

---


# Fin