{
  "hash": "fd82bfdec6052576628dda121b2afb0f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Fonctions SQL et Vues\"\nsubtitle: \"Fonctions SQL. Vues. Requêtes préparées\"\ndate: \"2024-10-11\"\n\nformat: \n  revealjs:\n    header: \"Fonctions SQL et Vues\"\n---\n\n\n\n\n\n\n\n# Requêtes paramétrées : pourquoi ? {background-color=\"#1c191c\"}\n\n\n---\n\n> SQL is much like chess—a few hours to learn, a lifetime to master\n\n\n---\n\n## Pourquoi ?\n\nLorsqu'une collection de requêtes de même forme est utilisée sur une base de données, \nil est pertinent de *préparer* ces requêtes\n\nLes objectifs de cette préparation sont divers: \n\n- éviter de coder de façon répétitive \n\n- permettre une planification en amont des requêtes\n\n- éviter de recalculer des jointures coûteuses\n\n- ...\n\n::: {.aside}\n\nOn cherche à suivre le principe `DRY` (Don't Repeat Yourself) plutôt que la routine `WET` (Write Everything Twice ou We Enjoy Typing)\n\n:::\n\n---\n\n## Comment ? \n\nLes SGBD relationnels offrent une gamme d'outils pour combler ces besoins \n\n- Les `PREPARED STATEMENT`\n\n- Les **fonctions** \n\n- Les **vues** \n\n\n\n\n# Fonctions SQL (version PostGreSQL): définition  {background-color=\"#1c191c\"}\n\n\n\n\n---\n\n\n> Dans SQL et dans PostgreSQL en particulier , il est possible de définir des fonctions ou procédures persistantes \n(`STORED PROCEDURE`)\n\n> Ces fonctions sont des *objets permanents* d'un schéma (comme les tables, vues, utilisateurs, etc)\n\n\n>  Elles permettent de regrouper un traitement complexe en un seul programme que l'on peut appeler à tout moment\nsi on en a le droit\n\n\n\n\n## Syntaxe générale des fonctions \n\n\n```{.sql}\nCREATE OR REPLACE FUNCTION \n  func_name(arg1 arg1_datatype DEFAULT arg1_default)\n\nRETURNS some type | set of some type | TABLE (..) AS\n$$\n\nBODY of function\n\n$$\nLANGUAGE language_of_function\n```\n\n::::: {.columns}\n::: {.column}\n\n`langage_of_function` peut \nprendre différentes valeurs :\n\n- `SQL`   (*Trusted*)\n- `PL/pgSQL`  (*Trusted*)\n- `C`\n- `PL/Python` (*Untrusted*)\n- ...\n\n:::\n::: {.column}\n\n```{.sql}\nSELECT lanname \nFROM pg_language;\n```\n\n```{.sql}\nlanname |\n--------+\ninternal|\nc       |\nsql     |\nplpgsql |\n```\n\n:::\n::::: \n\n---\n\n\n## Signature de la fonction\n\n```{.sql}\nCREATE OR REPLACE FUNCTION \n  <func_name>(<arg1> <arg1_datatype> [DEFAULT <arg1_default>])\n\nRETURNS <some type> | SETOF <some type> | TABLE (..)\n```\n\nLa signature d'une fonction est formée par:\n\n- le nom de la fonction  `<func_name>`\n- la liste des arguments (nom `<arg1>` et type attendu <arg1_datatype>)\n- le type du résultat retourné par la fonction\n\n\n\n## Signature de la fonction (suite)\n\n- `<arg1_datatype>`: \n  - type prédéfini ou non, voir  `CREATE TYPE ...`\n  - type de colonne d'une table : `country.countrycode%TYPE`\n  - type des tuples d'une table : `country%ROWTYPE`...\n\n- `<arg1_default>`: litéral ou expression \n\n- Type du résultat:\n  - type prédéfini ou non \n  - `SETOF ...` (table)\n  - `TABLE (...)` \n\n::: {.aside}\n\nChaque schéma de table définit (implicitement) un type \n\n:::\n\n\n---\n\n> Les arguments peuvent avoir des valeurs par défaut. Cela permet à l'appelant d'ommettre ces arguments.\n\n> Les arguments optionnels doivent être déclarés après les arguments non-optionnels dans la signature de la fonction.\n\n\n\n---\n\n## Types définis par l'usager \n\n```{.sql}\nCREATE TYPE  type_utilisateur AS (\n  <identifiant> <type défini>\n  [, <identifiant> <type défini>]*\n);\n```\n\nUsage pour une création de table \n\n```{.sql}\nCREATE TABLE <nom de table> OF \n  type_utilisateur\n  (CONSTRAINT <nom de contrainte> PRIMARY KEY  (<nom de colonne>));\n```\n\nPratique pour créer des tables de même schéma \n\n\n::: {.callout-note}\n\n### {{< fa hand-point-right >}} \n\n\nquand on crée une table, PostgreSQL crée automatiquement un type associé (bis)\n \n:::\n\n\n\n\n## Exemple \n\n- Définition d'un type \n\n```{.sql}\nCREATE TYPE basic_user AS (\n  user_name varchar(50), \n  pwd varchar(10)\n);\n```\n\n- Usage du type défini par usager\n\n```{.sql}\nCREATE TABLE super_users OF basic_user \n  (CONSTRAINT pk_su PRIMARY KEY  (user_name));\n```\n\n\n## Annotations\n\nLes définitions de fonctions comportent parfois des qualifications supplémentaires\n\n- `VOLATILITY`:  `IMMUTABLE`, `STABLE`, `VOLATILE` (default)\n\n- `SECURITY` : `SECURITY DEFINER`, `SECURITY INVOKER` \n\n\n## Les fonctions écrites en langage SQL \n\nSQL est d'abord un langage permettant d'émettre des requêtes, il peut aussi être utilisé pour\nécrire des fonctions\n\nDans PostgreSQL, l'utilisation d'un morceau de SQL existant est facile : \n\n- prenez vos instructions SQL existantes (éventuellement plusieurs)\n\n- ajoutez un en-tête et une conclusion fonctionnels\n\net ... vous avez terminé {{< fa champagne-glasses >}}\n \n\n\n## Les fonctions écrites en langage SQL (suite)\n\nMais cette facilité a un prix {{< fa face-frown >}}\n\nVous ne pouvez pas :\n\n- utiliser des structures de contrôle (boucles, alternatives) ou des définitions de variables locales \n\n- exécuter des instructions SQL *dynamiques*  que vous assemblez à la volée en utilisant les arguments passés dans la fonction\n\n. . .\n\nMais, tout de même \n\n- le planificateur de requêtes peut examiner une fonction SQL  et en optimiser l'exécution\n\n---\n\n> Les fonstions SQL  exécutent une suite arbitraire d'expressions (requêtes)  SQL, \nelles renvoient le résultat de la dernièrere requête. \n\n> In the simple (non-set) case, the first row of the last query's result will be returned.\n> Bear in mind that \"the first row\" of a multirow result is not well-defined unless you use ORDER BY.\n> If the last query happens to return no rows at all, the null value will be returned.\n\n\n\n\n\n## Corps de la fonction\n\n{{< fa hand-point-right >}} La syntaxe du corps de la fonction dépend du `language_of_function`\n\nDans le cas où `language_of_function` est `SQL`\n\n```{.sql}\n$$\n\nBODY of function\n\n$$\n```\n\n\n\n## Références aux argument \n\nOn peut faire références aux arguments en les nommant dans le corps de la fonction\n\nSi les arguments ne sont pas nommés, vous faites référence aux arguments par leur \nposition dans la signature : `$1`, `$2`, `$3`, etc\n\n\n{{< fa hand-point-right >}} Si vous nommez les arguments, vous pouvez utiliser la notation  \n\n```{.sql}\nbig_elephant(name => 'Wooly', ear_size => 1.2)\n```\n\nlors des appels à la fonction\n\n\n\n\n## Exemple\n\n```{.sql}\nCREATE OR REPLACE FUNCTION \n  write_to_log(param_user_name varchar,\n               param_description text)\nRETURNS integer AS\n$$\nINSERT INTO logs\n   (user_name, description) \n   VALUES($1, $2)\nRETURNING log_id;\n$$\nLANGUAGE 'sql' VOLATILE;\n```\n\n. . .\n\nInvocation\n\n```{.sql}\nSELECT write_to_log('alex', \n    'Logged in at 11:59 AM.') AS new_id;\n```\n\n---\n\nLes fonctions SQL peuvent retourner des ensembles\n\nTrois manières de faire:\n\n- ANSI SQL standard:  `RETURNS TABLE` \n\n- spécifier des paramètres `OUT`  et  retourner `SETOF RECORD` \n\n- types de données composés `SETOF ...` \n\n---\n\n## Exemple de fonction retournant un type simple\n\nDans le schéma `world`, on veut écrire une fonction qui prend en argument une région et \nrenvoie la population maximale parmi les capitales de la région\n\n```{.sql}\nCREATE OR REPLACE \n  FUNCTION username.taille_max_capitale_region(p_region text)\n  RETURNS INTEGER \n  LANGUAGE SQL AS\n$$\nSELECT MAX(population_city) AS max_pop\nFROM world.country c \n  JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region AND\n cc.population_city IS NOT NULL;\n$$ ;\n```\n\n\n\n# Fonctions qui retournent un type composé   {background-color=\"#1c191c\"}\n\n\n---\n\nDans le schéma `world`, on veut écrire une fonction qui prend en argument une région et \nrenvoie le nom et la population de la capitale la plus peuplée de cette région \n\nOn peut utiliser le qualifiant `OUT` pour désigner des paramètres de sortie.\n\n```{.sql}\nCREATE OR REPLACE \n  FUNCTION username.capitale(\n    p_region text, \n    OUT o_name_capital TEXT, \n    OUT o_population_capital INTEGER)\n  RETURNS RECORD  \n  LANGUAGE SQL AS\n$$\nWITH r AS (\n  SELECT cc.*, RANK() OVER (PARTITION BY c.region ORDER BY cc.population_city DESC) AS rnk\n  FROM world.country c JOIN \n    world.city cc ON (c.capital=cc.id)\n  WHERE c.region=p_region\n)\n\nSELECT r.name_city,  r.population_city\nFROM r \nWHERE r.rnk = 1 ;\n$$ ;\n```\n\n\n## Fonctions qui retournent un type composé défini par les lignes d'une table\n\nDans le schéma `world`, on veut écrire une fonction qui prend en argument une région et \nrenvoie la description de la capitale la plus peuplée de cette région \n\nOn se contente de nommer la table pour indiquer que le résultat doit avoir même structure \nqu'une ligne de la table\n\n```{.sql}\n  CREATE OR REPLACE FUNCTION username.capitale(p_region text)\n  RETURNS world.city  \n  LANGUAGE SQL AS\n  $$\n  WITH r AS(\n    SELECT cc.*, RANK() OVER (PARTITION BY c.region ORDER BY cc.population_city DESC) AS rnk\n    FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n    WHERE c.region=p_region)\n  SELECT r.id, r.name_city, r.countrycode, r.district, r.population_city\n  FROM r \n  WHERE r.rnk = 1 ;\n  $$ ;\n```\n\n\n\n## Fonctions qui retournent une table\n\nDans le schéma `world`, on veut écrire une fonction qui prend en argument une région et \nrenvoie la table des capitales de la région \n\n\n\n## Table de schéma explicite\n\nOn se contente d'abord de renvoyer le nom de la capitale. \n\nOn explicite le schéma  de la table résultat\n\n```{.sql}\nCREATE OR REPLACE FUNCTION username.capitales_region(p_region text)\nRETURNS TABLE (name_capital text) \nLANGUAGE SQL AS\n$$\nSELECT cc.name_city \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;\n```\n  \n\n\n## Table de même schéma qu'une autre table\n\n[https://www.postgresql.org/docs/15/xfunc-sql.html](https://www.postgresql.org/docs/15/xfunc-sql.html)\n\n\nOn veut maintenant récupérer une table de même schéma que `city`. \n\nLa solution est très simple. \n\nOn profite de ce qu'à chaque table correspond  un type de même nom et on utilise le mot-clé `SETOF`. \n\n```{.sql}\nCREATE OR REPLACE FUNCTION username.capitales_region_large(p_region text)\nRETURNS SETOF world.city  \nLANGUAGE SQL AS\n$$\nSELECT cc.* \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;\n```\n\n\n\n\n\n## Autres langages \n\n- PL/pgSQL\n- C\n\n- PL/Python\n- PL/R \n- ...\n\n\n\n# Fonctions SQL: usages    {background-color=\"#1c191c\"}\n\n\n---\n\n![](/images/pagila_full.png)\n\n\n\n## Fonction reprise depuis `pagila`\n\n```{.sql}\nCREATE OR REPLACE FUNCTION user.inventory_held_by_customer(\n    p_inventory_id integer,\n    OUT customer_id int2) AS \n$$\n  SELECT customer_id \n  FROM pagila.rental\n  WHERE return_date IS NULL AND inventory_id = p_inventory_id ;\n$$ LANGUAGE 'sql' ;\n```\n\n\n\n## Fonctions de `pagila`\n\n```{.sql}\nCREATE OR REPLACE FUNCTION uname.film_in_stock(\n  p_film_id integer, \n  p_store_id integer, \n  OUT p_film_count integer)\n RETURNS SETOF integer\nAS $$\n     SELECT inventory_id\n     FROM pagila.inventory\n     WHERE film_id = $1\n     AND store_id = $2\n     AND pagila.inventory_in_stock(inventory_id);\n$$ LANGUAGE sql ;\n```\n\n---\n\n## Invocation \n\n\n```{.sql}\nSELECT * \nFROM pagila.film_in_stock(12, 1) ;\n```\n\n\n|p_film_count|\n|-----------:|\n|          60|\n|          61|\n|          62|\n\n\n# Vues : pourquoi ?   {background-color=\"#1c191c\"}\n\n\n\n## {.smaller}\n\n> Presque tous les SGBD relationnels proposent des vues comme niveau d'abstraction des tables. Dans une vue, vous pouvez interroger plusieurs tables et présenter des colonnes dérivées supplémentaires basées sur des calculs complexes. \n\n> Les vues sont généralement en lecture seule, mais PostgreSQL vous permet de mettre à jour les données sous-jacentes en mettant à jour la vue, à condition que la vue provienne d'une seule table. \n\n> Pour mettre à jour des données à partir de vues qui joignent plusieurs tables, vous devez créer une gachette contre la vue.\n\n>  Les vues matérialisées mettent en cache les données afin d'accélérer les requêtes les plus courantes, au détriment des données les plus récentes. \n\n\n\n## Motivation\n\n::: {.callout-tip}\n\nSi vous vous retrouvez à écrire tous les jours la même requête, créer une vue !\n\n:::\n\nUne vue n'est rien d'autre qu'une requête stockée de façon persistante\n\n\n## Vues sur une seule table \n\n```{.sql}\nCREATE OR REPLACE VIEW co_asia AS\nSELECT * \nFROM world.country \nWHERE continent = 'Asia' ;\n```\n\n\n## Interroger une vue \n\nUne vue s'interroge comme une table :\n\n```{.sql}\nSELECT region, sum(population_country) AS pop \nFROM co_asia \nGROUP BY region \nORDER BY pop DESC ;\n```\n\n\n\n```\nregion                   |pop       |\n-------------------------+----------+\nEastern Asia             |1507328000|\nSouthern and Central Asia|1490776000|\nSoutheast Asia           | 518541000|\nMiddle East              | 188380700|\n```\n\n\n\n\n\n## Vues et manipulation de données \n\nSi\n\n- la vue (`VIEW`) provient d'une table unique \n- la vue contient la *clé primaire* de la table d'origine \n\nAlors \n\non peut modifier la table au travers de la vue. On peut\n\n- insérer\n- supprimer \n- mettre à jour\n\n::: {.callout-note}\n\n### Exemple\n\n- La vue `co_asia` provient d'une unique table : `world.country`\n- La vue `co_asia` contient la *clé primaire* `countrycode` de la table `world.country` \n\n:::\n\n\n\n\n## {{< fa triangle-exclamation >}}\n\nCette instruction :\n\n```{.sql}\nUPDATE co_asia\n  SET continent='Antarctica';\n\n```\n\n... est légale !\n\n--\n\nMais, après exécution :\n\n- la vue `co_asia`  est vide  {{< fa face-frown >}}\n\n- les pays d'Asie de `country` sont délocalisés en Antarctique  {{< fa face-laugh >}}\n\n\n\n\n## Pour éviter ca : `WITH CHECK OPTION `\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|6\"}\nCREATE OR REPLACE VIEW boucheron.co_asia AS\n  SELECT * \n  FROM world.country \n  WHERE continent = 'Asia' \n\nWITH CHECK OPTION ;\n```\n:::\n\n\n\nAjouter cette modification lors de la création de la vue et \nPostgreSQL s'opposera à une tentative d'insertion hors de la vue ou \nà une tentative de mise à jour qui placerait des tuples hors de la vue\n\n\n\n## {.smaller}\n\n\n```{.sql}\nCREATE OR REPLACE VIEW pagila.actor_info\nAS SELECT a.actor_id,\n    a.first_name,\n    a.last_name,\n    pagila.group_concat(DISTINCT (c.name::text || ': '::text) || \n        (( SELECT pagila.group_concat(f.title::text) AS group_concat\n           FROM pagila.film f\n             JOIN pagila.film_category fc_1 ON f.film_id = fc_1.film_id\n             JOIN pagila.film_actor fa_1 ON f.film_id = fa_1.film_id\n          WHERE fc_1.category_id = c.category_id AND fa_1.actor_id = a.actor_id\n          GROUP BY fa_1.actor_id))\n        ) AS film_info\n   FROM pagila.actor a\n     LEFT JOIN pagila.film_actor fa ON a.actor_id = fa.actor_id\n     LEFT JOIN pagila.film_category fc ON fa.film_id = fc.film_id\n     LEFT JOIN pagila.category c ON fc.category_id = c.category_id\n  GROUP BY a.actor_id, a.first_name, a.last_name;\n```\n\n\n## Vues multi-tables : exemple de vue sur `world` {.smaller}\n\n\n```{.sql}\nCREATE OR REPLACE VIEW country_info AS\n\n  SELECT\n    cn.countrycode, \n    cn.name_country, \n    cn.region,\n    string_agg(DISTINCT ci.name_city::text , ', '::text) AS cities\n\n  FROM world.country cn LEFT JOIN \n       world.city ci \n       ON (cn.countrycode = ci.countrycode)\n\n  GROUP BY cn.countrycode, cn.name_country, cn.region;\n```\n\n\n[Stackoverflow](https://stackoverflow.com/questions/2560946/postgresql-group-concat-equivalent)\n\n\n\n## Insertion/Mise à jour/Suppression sur les vues multi-tables\n\n\nProblème : quelles tables doivent être modifiées ? \n\n```{.sql}\nDELETE \nFROM boucheron.country_info\nWHERE countrycode = 'FRA' ;\n```\n\n- supprimer les lignes de `country` ? \n\n- supprimer les lignes de `city` ?\n\n[Database abstraction](http://www.postgresonline.com/journal/archives/11-Database-Abstraction-with-updatable-Views.html)\n\n\n## Vues matérialisées\n\n\nLes vue matérialisées *cachent* les données récupérées\n\nCela se produit \n\n- lors  de la création de la vue et  \n\n- lorsque on exécute `REFRESH MATERIALIZED VIEW ...`\n\n\n---\n\n\n> Lorsque vous marquez une vue comme matérialisée, elle n'interrogera à nouveau les données que lorsque vous lancerez la commande `REFRESH`.\n\n> L'avantage est que vous ne gaspillez pas de ressources en exécutant des requêtes complexes à plusieurs reprises ; \n\n> lL'inconvénient est que vous risquez de ne pas avoir les données les plus à jour lorsque vous utilisez la vue.\n\n\n\n\n# References {background-color=\"#1c191c\"}\n\n\n---\n\n- [Postgresql Bloggers](https://planet.postgresql.org)\n\n---\n\n# Fin {background-color=\"#1c191c\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}