{
  "hash": "d6484d275c59f00b1ec386f9861158d6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BD II: SQL I\"\nsubtitle: \"Langage Manipulation de Données 1\"\ndate: \"2024-09-20\"\n\nformat: \n  revealjs:\n    header: \"Requêtes SQL simples\"\n---\n\n\n\n\n# Introduction  {background-color=\"#1c191c\"}\n\n\n\n\n##  SQL : Structured Query Language\n\n\nSQL est langage permettant :\n\n- _interrogation_ des données (requêtes)\n\n- _définition_ des données et des contraintes structurelles sur celles-ci\n\n- _manipulation_ des données (insertion, suppression, mise à\n  jour)\n\n- définition des _vues_ et des _index_\n\n- _administration_ des bases de données\n\n\n\n## Plusieurs fois normalisés par l'ISO ...\n\n- SQL-86,\n- SQL-89,\n- SQL-92,\n- SQL-99.\n- ...\n- SQL-2003\n- SQL-2008\n- SQL-2011\n- SQL-2016\n- ...\n\nNous utiliserons le dialecte [`PostgreSQL`](https://www.postgresql.org)\n\n\n\nA standard is reviewed every 5 years (roughly)\n\n[ISO/IEC 9075 from www.iso.org](https://www.iso.org/standard/63555.html)\n\n\n\n## SQL\n\n:::::: {.columns}\n\n::: {.column}\n\nUne instruction SQL permet de _combiner_ :\n\n- restriction/filtrage (sélection) $\\sigma$\n\n- projection $\\pi$\n\n- renommage $\\rho$\n\n-  ...\n\n\n:::\n\n. . .\n\n::: {.column}\n\nL'instruction\n\n\n```{.sql}\nSELECT <liste attribut>\n\nFROM <table>\n\nWHERE <condition> ;\n```\n\n\ntraduit l'expression\n\n$\\Pi_{\\text{<liste attribut>}}(\\sigma_{\\text{<condition>}}(\\text{<table>}))$\n\nOu `σ(R, Condition) |> Π(<liste attribut>)`\n\n:::\n\n::::::\n\n\n\n---\n\nOn peut faire autrement : dans les extensions du langage `R`, notamment celles qui relèvent de `tidyverse`, on associe des fonctions à chaque opérateur de l'algèbre\nrelationnelle. Pour opérateurs qui portent sur une seule table, le premier argument\nde chaque fonction est toujours la table sur laquelle on opère. Les autres arguments\nsont soit les attributs de projection, soit la spécification d'une condition de sélection, soit ...\n\nL'usage d'un opérateur `pipe` (comme dans Unix) permet de composer de facon lisible les opérations.\n\n```\n<table> |>\n  filter(<condition> ) |>\n  select(<liste attribut>) |> \n  ...\n```\n\n\n\n## Syntaxe - requêtes simples\n\n\n:::::: {.columns}\n\n::: {.column}\n\n```{.sql}\nSELECT [DISTINCT] * | <liste attribut>\n\nFROM <liste de tables>\n\n[WHERE <condition>] ;\n```\n\n:::\n\n::: {.column}\n\n- `*` : sélection de tous les attributs (le schéma reste inchangé)\n\n- `[...]` : clause, expression facultative.\n\n- `DISTINCT` : supprime les doublons.\n\n:::\n\n:::::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(\n  require(DBI),\n  require(RPostgres)\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.sql .cell-code}\nSET search_path TO world ;\n```\n:::\n\n\n\n## Requêtes simples sur exemple jouet\n\n\n:::::: {.columns}\n\n::: {.column}\n\n```{.sql}\nEmploye(Nu, NomE, Annee, Tel, Nudept)\n\nFournisseur (NomF, Ville, Adresse)\n\nPiece(NomP, Prix, Couleur)\n```\n\n:::\n\n\n::: {.column}\n\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT co.name_country, co.region\nFROM country co\nWHERE co.continent='Europe' \nLIMIT 5 ;\n```\n:::\n\n\n\n\n\n\nEquivalent à :\n\n$$\\Pi_{\\text{NomF, region}}(\\text{country})$$\n\n:::\n\n::::::\n\n\n\n---\n\n\n```{.sql}\nSELECT *\n\nFROM Fournisseur ;\n```\n\nEquivalent à : `Fournisseur`\n\n\n```{.sql}\nSELECT *\n\nFROM Fournisseur\n\nWHERE Ville='Paris' ;\n```\n\nEquivalent à : $\\sigma_{\\texttt{Ville}=\\texttt{'Paris'}}(\\texttt{Fournisseur})$\n\n\n# Requêtes mono-relation {background-color=\"#1c191c\"}\n\n\n\n## Structure de base\n\nLa structure de base d'une requête s'appuie sur les trois mots\nclés suivants :\n\n- `SELECT` correspond à l'opérateur de projection sur la liste d'attributs demandée, il peut aussi être suivi de fonctions d'attributs\n\n- `FROM` indique la ou les relations concernées\n\n- `WHERE` précise une condition et correspond à l'opération de restriction/sélection en algèbre relationnelle.\n\n\n---\n\n## Syntaxe de la condition de filtrage (`WHERE ...`)\n\n\nUne condition se construit à l'aide des opérations suivantes :\n\n- *Comparaison* avec opérateurs : `=, <>, >,<, >=, <=`\n\n```{.sql}\nSELECT *\n\nFROM Employe\n\nWHERE NomE <>'Durand'  ;  \n```\n\n\n\n## Syntaxe de la condition de filtrage (`WHERE ...`)\n\n*Combinaison* de conditions à l'aide des opérateurs logiques:  `AND`, `OR`, `NOT`\n\n```{.sql}\nSELECT DISTINCT NomF\n\nFROM Fournisseur\n\nWHERE (Ville='Londres') OR (Ville='Paris');  \n```\n\n\n{{< fa triangle-exclamation >}} Attention aux priorités dans l'évaluation des expressions logiques\n\n\n{{< fa skull >}} Attention aux valeurs manquantes\n \n---\n\n\n## Syntaxe de la condition `WHERE ...` (suite)\n\nTest *BETWEEN* permettant de vérifier si la valeur d'un attribut est comprise entre deux constantes\n\n\n```{.sql}\nSELECT NomE\n\nFROM Employe\n\nWHERE Annee BETWEEN '22/06/03' AND '25/09/03';   \n```\n\n\n{{< fa triangle-exclamation >}} Éviter de manipuler les dates et heures comme des chaînes de caractères\n\n---\n\n## Syntaxe de la condition `WHERE ...` (suite)\n\n- Test à `NULL` signifiant que la valeur est égale à `NULL` (c-à-d est inconnue)\n\n```{.sql}\nSELECT *\n\nFROM Employe\n\nWHERE Tel IS NULL;    \n```\n\n{{< fa skull >}} Attention aux valeurs manquantes\n\n\n---\n\n## Syntaxe de la condition `WHERE ...` (suite)\n\n\nTest d'*appartenance* `IN` qui permet de vérifier si la valeur d'un attribut appartient à une liste de constantes,\n\n```{.sql}\nSELECT *\n\nFROM Fournisseur\n\nWHERE Ville IN ('Paris', 'Londres');   \n```\n\n---\n\n## Syntaxe de la condition `WHERE ...` (suite)\n\nTest `LIKE` permettant de vérifier si un attribut de type chaîne de\ncaractères contient une ou plusieurs sous-chaînes\n\n$\\_$ : remplace n'importe quel caractère\n\n$\\%$ : remplace n'importe quelle chaîne de caractères.\n\n```{.sql}\nSELECT Ville\n\nFROM Fournisseur\n\nWHERE Ville LIKE 'Saint%';\n```\n\n\n\n\n\n# Requêtes multi-relations  {background-color=\"#1c191c\"}\n\n\n\n\n## Requêtes multi-relations\n\nQuand l'information est dispersée sur plusieurs tables, on utilise des *jointures*\n\n\n\n\n## On peut :\n\n\n- utiliser plusieurs tables dans la clause `FROM`\n\n- faire intervenir des conditions complexes impliquant ces tables dans la clause `WHERE`\n\n\n\n\n\n\n## Détails du schema `World`\n\nImages et tables créées grâce à [DbSchema](https://dbschema.com)\n\n\n\n\n## Diagramme en pattes de corbeau\n\n![img](/images/world.png)\n\n\n\n## Table world.city \n\n| | | |\n|---|---|---|\n| * &#128273;  &#11019; | id| integer  |\n| * | name| text  |\n| * | countrycode| char(3)  |\n| * | district| text  |\n| * | population| integer  |\n\n\n\n\n## Table world.country \n\n| | | |\n|---|---|---|\n| * &#128273;  &#11019; | code| char(3)  |\n| * | name| text  |\n| * | continent| text  |\n| * | region| text  |\n| * | surfacearea| real  |\n|  | indepyear| smallint  |\n| * | population| integer  |\n|  | lifeexpectancy| real  |\n|  | gnp| numeric(10,2)  |\n|  | gnpold| numeric(10,2)  |\n| * | localname| text  |\n| * | governmentform| text  |\n|  | headofstate| text  |\n| &#11016; | capital| integer  |\n| * | code2| char(2)  |\n\n\n### Foreign Keys\n\n| | | |\n|---|---|---|\n|  | country_capital_fkey | ( capital ) ref [world.city](#city) (id) |\n\n\n### Constraints\n\n| | |\n|---|---|\n| country_continent_check | ((continent = 'Asia'::text) OR (continent = 'Europe'::text) OR (continent = 'North America'::text) OR (continent = 'Africa'::text) OR (continent = 'Oceania'::text) OR (continent = 'Antarctica'::text) OR (continent = 'South America'::text)) |\n\n\n\n\n## Table world.countrylanguage \n\n| | | |\n|---|---|---|\n| * &#128273;  &#11016; | countrycode| char(3)  |\n| * &#128273;  | language| text  |\n| * | isofficial| boolean  |\n| * | percentage| real  |\n\n\n### Foreign Keys\n\n| | | |\n|---|---|---|\n|  | countrylanguage_countrycode_fkey | ( countrycode ) ref [world.country](#country) (code) |\n\n\n\n\n##  Première jointure sur schéma `world`\n\nQuels sont les pays qui portent le même nom que leur capitale ?\n\n. . .\n\n```{.sql}\nSELECT name_country\n\nFROM country, city    \n\nWHERE capital=id AND name_country=name_city;\n```\n\n. . .\n\nqui correspond à\n\n$$\\pi_{\\text{name\\_country}}(\\sigma_{\\text{capital}=\\text{id} \\wedge \\text{name\\_country}=\\text{name\\_city}}(\\text{country}\\times \\text{city}))$$\n\nautrement dit à\n\n$$\\pi_{\\text{name\\_country}}(\\text{country} \\bowtie_{\\text{capital}=\\text{id} \\wedge  \\text{name\\_country}=\\text{name\\_city}} \\text{city}))$$\n\n\n\n## Syntaxe normalisée pour les jointures : *JOIN* et *ON*\n\nQuels sont les pays qui portent le même nom que leur capitale ?\n\n```{.sql}\nSELECT name_country\n\nFROM country JOIN city   \n\nON capital=id    \n\nWHERE name_country=name_city;\n```\n\nqui correspond à\n\n$$\\pi_{\\text{name\\_country}}(\\sigma_{\\text{capital}=id \\wedge  \\text{name\\_country}=\\text{name\\_city}}(\\text{country} \\times \\text{city}))$$\n\n\n\n## Renommage\n\n\nSi on veut faire une jointure d'une table avec elle-même, on utilise *AS*\npour obtenir deux tables de noms différents\n\n- Quels sont les noms de ville qui apparaissent dans deux pays différents~?\n\n\n```{.sql}\nSELECT DISTINCT c1.name_city, c1.countrycode, c2.countrycode\n\nFROM city AS c1 JOIN city AS c2   \n\n  ON c1.countrycode!=c2.countrycode AND c1.name_city=c2.name_city  \n\nORDER BY c1.name_city;\n```\n\n\n\n\n## Jointure naturelle\n\nQuels sont les noms des pays où le français est parlé ?\n\n\n```{.sql}\nSELECT name_country\n\nFROM country, countrylanguage\n\nWHERE country.countrycode=countrylanguage.countrycode\n      AND language='French';\n```\n\nSyntaxe normalisée pour la jointure naturelle~: *NATURAL JOIN*\n\n```{.sql}\nSELECT name_country\n\nFROM country NATURAL JOIN countrylanguage    \n\nWHERE language='French';\n```\n\n\n\n## Jointure naturelle (suite)\n\nQuels sont les pays dont une ville a le même nom qu'une langue parlée dans ce pays~?\n\n```{.sql}\nSELECT DISTINCT name_country, name_city, language\n\nFROM country NATURAL JOIN  \n     city natural JOIN     \n     countrylanguage       \n\nWHERE language=name_city;\n```\n\n\n---  \n\n![](/images/world.png)\n\n\n\n\n\n## Jointure externe\n\n\n\n- *LEFT OUTER JOIN* (resp. *RIGHT OUTER JOIN*) : on garde les tuples de la table de gauche (resp. droite) qui n'ont pas de complément dans l'autre table, la condition étant spécifiée dans la clause *ON*\n\n- *FULL OUTER JOIN* : on garde les tuples de chacune des tables qui n'ont pas de complément.\n\n- On complète les valeurs non renseignées par *NULL*\n\n\n\n## Exemple de jointure externe\n\n\n\n- Certains pays n'ont pas de capitale : la requête\n\n```{.sql}\nSELECT name_country\n\nFROM country\n\nWHERE capital IS NULL;\n```\n\nrenvoie 8 lignes.\n\n\n\n- Quels sont les pays qui n'ont pas de capitale ou portent le même nom que leur capitale~?\n\n```{.sql}\nSELECT name_country, name_city\n\nFROM country LEFT OUTER JOIN city   \n     ON capital=id                  \n\nWHERE name_city IS NULL OR name_country=name_city ;   \n```\n\n\n\n\n\n# Fin   {background-color=\"#1c191c\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}