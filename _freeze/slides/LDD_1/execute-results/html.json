{
  "hash": "58627ec93ab714711eca3e9bd9db91ef",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BD : Contraintes\"\nsubtitle: \"Définition de données: Contraintes\"\ndate: \"2024-10-11\"\n\nformat: \n  revealjs:\n    header: \"Contraintes\"\n---\n\n\n\n\n\n\n\n\n# Introduction  {background-color=\"#1c191c\"}\n\n---\n\n## Problème\n\n- La définition d'un schéma de base ne s'arrête pas à la définition des\ntables, des colonnes et des types des colonnes\n\n. . . \n\n- Les *contraintes* décrivent des propriétés que devront vérifier\ntoutes les mises en oeuvre (instances) du schéma *durant toute sa durée de vie*\n\n{{< fa triangle-exclamation >}} La définition d'un schéma de base ne s'arrête pas à la définition des\ntables, des colonnes et des types des colonnes\n\n\nLes *contraintes* décrivent des propriétés que devront vérifier\ntoutes les mises en oeuvre (instances) du schémas *durant toute leur durée de vie*\n\n\n{{< fa hand-point-right >}}  Pour spécifier une *contrainte*, il suffit de préciser que le\nrésultat d'une certaine requête doit toujours être vide\n\n\n\n## Famille de contraintes\n\n- Contraintes d'attribut \n\n  - Contrainte de **type**  \n  - Contrainte de **non-nullité**   \n\n. . .\n\n- Contraintes de tupe \n\n  - Contrainte de **vérification**  \n\n. . .\n\n- Contraintes de table \n    \n  - Contrainte de **clé primaire**  \n  - Contrainte d'**unicité** \n  - Contrainte d'**unicité avancée** \n  - Contraintes d'**exclusion**  \n\n. . .\n\n- Contraintes multi-tables  \n  - Contraintes  de **clé étrangère** \n\n\n# Contraintes de type  {background-color=\"#1c191c\"}\n\n\n\n## Contrainte de type\n\nUne contrainte de type spécifie le type/domaine  d'une colonne\n\nLes contrainte de type sont les plus simples à mettre en oeuvre. \n\n. . . \n\nAu delà des types de base `varchar, integer, ...`  `PostgreSQL` propose\ndes types sophistiqués pour :\n\n- [dates](https://www.postgresql.org/docs/current/datatype-datetime.html), \n- [les estampilles avec ou sans\nfuseau horaire](https://www.postgresql.org/docs/current/datatype-datetime.html#DATATYPE-DATETIME-INPUT-TIME-STAMPS), \n- des types intervalles (`rangetype`), \n- [des types énumérés](https://www.postgresql.org/docs/current/datatype-enum.html), \n- [des types tableaux](https://www.postgresql.org/docs/current/arrays.html), \n- etc\n\n\n\n## Consulter la liste des types\n\n[https://docs.postgresql.fr/docs/current/datatype.html](https://docs.postgresql.fr/docs/current/datatype.html)\n\n\nIl faut essayer d'utiliser ces types pour préciser les contenus des colonnes\n\n::: {.callout-tip}\n\n### Conseil \n\nIl faut essayer d'utiliser autant que possible ces types pour préciser les contenus des colonnes\n\nCela permet de contraindre les contenus \n\nCela permet d'utiliser une foule de fonctions de manipulation très pratiques, notamment pour l'arithmétique du temps\n\n:::\n\n. . .\n\n::: {.callout-caution}\n\n### {{< fa skull-crossbones >}} \n\nLes types disponibles diffèrent d'un SGBD à l'autre (`Mysql`, `Postgres`, `Oracle`, `SQL Server`, ...)\n\n:::\n\n\n# Contrainte de vérification `CHECK` {background-color=\"#1c191c\"}\n\n\n\n## Contraintes de tuple\n\nUne **contrainte de tuple** peut être vérifiée tuple par tuple (ligne par ligne)\n\n. . . \n\nLors d'une insertion ou d'une modification de tuple, il *suffit* de\nvérifier que la contrainte est respectée par le nouveau tuple \n\n\n\n## Exemple\n\nDans un tuple de  `Piece`, on devrait toujours avoir\nune valeur du prix positive. \n\nOn peut imposer cela en\najoutant au schéma de la table  `Piece` une contrainte de\ntype  `CHECK`\n\n\n\n## Exemple (suite)\n\n```{.sql}\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix MONEY CHECK (prix>= 0::money), \n    couleur VARCHAR(15)\n);\n```\n\n. . . \n\n::: {.callout-note}\n\nHave a look at [PostGres Monetary type](https://www.postgresql.org/docs/current/datatype-money.html)\n\n:::\n\n\n\n\n## Exemple `world.country`  {.smaller}\n\nDans un tuple de `country`, les colonnes numériques ne devraient\npas prendre de valeur négative\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|6,9,17-22\"}\nCREATE TABLE world.country (\n\tcountrycode BPCHAR(3) NOT NULL,\n\tname_country TEXT NOT NULL,\n\tcontinent TEXT NOT NULL,\n\tregion TEXT NOT NULL,\n    surfacearea FLOAT4 CHECK (surfacearea>= 0) NOT NULL, \n\tindepyear INT2 NULL,\n    population_country INT4 NOT NULL,\n    lifeexpectancy FLOAT4 CHECK (lifeexpectancy>= 0) NULL, \n    gnp NUMERIC(10, 2) NULL,    \n    gnpold NUMERIC(10, 2) NULL,  \n\tlocalname TEXT NOT NULL,\n\tgovernmentform TEXT NOT NULL,\n\theadofstate TEXT NULL,\n\tcapital INT4 NULL,\n\tcode2 BPCHAR(2) NOT NULL,\n\tCONSTRAINT country_continent_check CHECK (\n        ((continent = 'Asia'::text) OR (continent = 'Europe'::text) OR \n         (continent = 'North America'::text) OR (continent = 'Africa'::text) OR \n         (continent = 'Oceania'::text) OR (continent = 'Antarctica'::text) OR \n         (continent = 'South America'::text))),\n\tCONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);\n```\n:::\n\n\n\n\n\n## Contrainte de vérification - Exemple (suite)\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|3,4,6\"}\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix moNey CHECK (prix>= 0::money),  \n    prix_promo MONEY CHECK (prix_promo >= 0::MONEY), \n    couleur VARCHAR(15),\n    CHECK(prix > prix_promo) \n); \n```\n:::\n\n\n\n. . . \n\n```{.sql}\nINSERT INTO piece \n  VALUES\n  ('x21', 1.51, 1.61,'rouge');\n```\n\n`ERROR:  new row for relation \"piece\" violates check constraint piece_check` {{< fa face-angry >}}\n\n. . . \n\n```{.sql}\nINSERT INTO piece VALUES('x21', 1.51, null,'rouge');\n```\n\nest accepté  {{< fa champagne-glasses >}}\n\n\n\n\n\n## {{< fa triangle-exclamation >}}  Valeurs nulles et  contraintes de tuple\n\nLes contraintes  `CHECK` sont satisfaites si l'expression associée vaut  `TRUE` ou  `NULL` \n\n. . . \n\nComme une expression composée vaut parfois `NULL` si l'un\ndes opérandes vaut lui-même  `NULL`, les contraintes  `CHECK` ne\nsuffisent pas à prévenir l'insertion de valeurs nulles\n\n. . . \n\n::: {.callout-tip}\n\nIl faut  compléter les contraintes de tuple  avec des *contraintes de non-nullité*\n\n:::\n\n\n\n# Contrainte de non-nullité  (NOT NULL)  {background-color=\"#1c191c\"}\n\n\n \n\n## Pourquoi imposer qu'une colonne soit toujours renseignée ?\n\n::: {.callout-important}\n\nLa présence possible des valeurs nulles rend beaucoup d'opérations complexes \n\nIl faut avoir en tête que en `SQL`, \n\n- les booléens peuvent avoir trois valeurs : `TRUE, FALSE` et  `NULL` et que \n\n- le fait qu'une expression ne vaille pas  `FALSE` ne veut pas dire qu'elle\nvaut  `TRUE` ...\n \n:::\n\n. . . \n\nPour imposer qu'une colonne soit renseignée :\n\n- préciser après le type : `NOT NULL`\n\n\n\n\n## Contrainte de non-nullité (Exemple)\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|2\"}\nCREATE TABLE piece(\n    nomp VARCHAR(20) NOT NULL,\n    prix MONEY CHECK (prix>= 0::MONEY),  \n    prix_promo MONEY CHECK (prix_promo >= 0::MONEY),  \n    couleur VARCHAR(15),\n    CHECK (prix > prix_promo)   \n); \n```\n:::\n\n\n\n\n\n# Contrainte d'unicité  {background-color=\"#1c191c\"}\n\n\n\n## Contrainte d'unicité\n\n- Les contraintes d'unicité garantissent l'unicité des données contenues dans une colonne \nou un groupe de colonnes par rapport à toutes les lignes de la table\n\n- C'est une *contrainte de table* puisqu'elle fait intervenir tous les tuples de la table\n\n---\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|2\"}\nCREATE TABLE piece(\n    nomp VARCHAR(20) NOT NULL UNIQUE,  \n    prix money CHECK (prix>= 0::money),\n    prix_promo MONEY CHECK (prix_promo >= 0::MONEY),\n    couleur VARCHAR(15),\n    CHECK (prix > prix_promo)\n);\n```\n:::\n\n\n\n\n## Contrainte d'unicité   \n\n::: {.callout-note}\n\nLa contrainte d'unicité peut porter sur un *groupe de colonnes*\n\n:::\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|4\"}\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20) NOT NULL,\n    villef VARCHAR(20) NOT NULL,\n    UNIQUE(nomf, villef)  \n);\n```\n:::\n\n\n\n::: {.aside}\n\n{{< fa hand-point-right >}} Il ne peut pas y avoir deux lignes identiques dans la table `fournisseur`\n\n:::\n\n\n\n# Clef primaire  {background-color=\"#1c191c\"}\n\n \n\n## Clef primaire : **PRIMARY KEY**\n\n::: {.callout-important}\n\n### Définition\n\nUne contrainte de type *clef primaire* indique qu'une colonne, ou un groupe de colonnes, \npeuvent être utilisée comme un *identifiant* unique de ligne pour cette table.\n\n:::\n\n. . .\n\n::: {.callout-note}\n\nCeci nécessite que les valeurs soient à la fois uniques et `NON NULL`. \n\n:::\n\n. . .\n\nLes définitions de table suivantes acceptent de ce fait les mêmes données\n\n::::: {.columns}\n\n::: {.column}\n```{.sql}\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20) NOT NULL,\n    villef VARCHAR(20) NOT NULL,\n    UNIQUE(nomf, villef)  \n);\n```\n:::\n\n::: {.column}\n```{.sql}\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20),\n    villef VARCHAR(20),\n    PRIMARY KEY (nomf, villef)  \n);\n```\n:::\n\n:::::\n\n::: {.aside}\n\n{{< fa triangle-exclamation >}} Une table a au plus une clef primaire\n\n:::\n\n\n\n# Clef étrangère  {background-color=\"#1c191c\"}\n\n\n\n## Clef étrangère\n\n\n- Une contrainte de clef étrangère stipule que les valeurs d'une colonne (ou d'un groupe de colonnes) doivent correspondre aux valeurs qui apparaissent dans les lignes d'une autre table.\n\n- On dit que cela maintient l'*intégrité référentielle* entre les deux tables\n\n- Soit les deux tables suivantes\n\n::::: {.columns}\n\n::: {.column}\n\n```{.sql}\nCREATE TABLE fournisseur(\n    idf INT PRIMARY KEY,\n    nomf VARCHAR(20),\n    villef VARCHAR(20)\n);\n```\n\n:::\n\n::: {.column}\n\n```{.sql}\nCREATE TABLE piece(\n    nomp VARCHAR(20) PRIMARY KEY,\n    prix MONEY CHECK \n        (prix>= 0::MONEY),\n    prix_promo MONEY CHECK \n        (prix_promo >= 0::MONEY),\n    couleur VARCHAR(15),\n    CHECK (prix > prix_promo)\n);\n```\n:::\n\n:::::\n\n\n\n## Clef étrangère : REFERENCES\n\n- Soit également une table `livraison` qui stocke les livraisons de ces pièces\n\n- Il est intéressant de s'assurer que la table  `livraison` ne contient que des \nréférences de pièces et de fournisseurs qui existent dans la base\n\nPour cela, deux  contraintes de *clef étrangère* sont  *émises* par la table des livraisons \n\n- Une contrainte *référence*  `piece` \n- Une contrainte *référence*  `fournisseur`\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|3,4\"}\nCREATE TABLE livraison(\n    numliv INT PRIMARY KEY,\n    idf INT REFERENCES fournisseur,   \n    nomp VARCHAR(20) REFERENCES piece,  \n    dateLiv DATE DEFAULT NOW(),\n    quantite INT DEFAULT 1 CHECK (quantite>=0)\n);\n \n```\n:::\n\n\n\n. . .\n\n::: {.aside}\n\n- Il est désormais impossible de créer des livraisons pour lesquelles les valeurs non `NULL` de `nomp` \nn'apparaissent pas dans la table `piece` et les valeurs non `NULL` de `idf` n'apparaissent pas dans la table `fournisseur`\n\n- On dit que la table des livraisons est la table qui référence et la table des pièces est la table référencée\n\n:::\n\n\n## Définition de `world.countrylanguage`\n\n```{.sql}                                                                                                \n+-------------+--------------+-------------+\n| Column      | Type         | Modifiers   |\n|-------------+--------------+-------------|\n| countrycode | character(3) |  not null   |\n| language    | text         |  not null   |\n| isofficial  | boolean      |  not null   |\n| percentage  | real         |  not null   |\n+-------------+--------------+-------------+\nIndexes:\n    \"countrylanguage_pkey\" PRIMARY KEY, btree (countrycode, language)\n```\n\n\n## Définition de `world.country`  {.smaller}\n\n::::: {.columns}\n::: {.column}\n\n```{.sql}                                                                                                \n+--------------------+---------------+-------------+\n| Column             | Type          | Modifiers   |\n|--------------------+---------------+-------------|\n| countrycode        | character(3)  |  not null   |\n| name_country       | text          |  not null   |\n| continent          | text          |  not null   |\n| region             | text          |  not null   |\n| surfacearea        | real          |  not null   |\n| indepyear          | smallint      |             |\n| population_country | integer       |  not null   |\n| lifeexpectancy     | real          |             |\n| gnp                | numeric(10,2) |             |\n| gnpold             | numeric(10,2) |             |\n| localname          | text          |  not null   |\n| governmentform     | text          |  not null   |\n| headofstate        | text          |             |\n| capital            | integer       |             |\n| code2              | character(2)  |  not null   |\n+--------------------+---------------+-------------+\n```\n\n:::\n\n::: {.column}\n\n```{.sql}\nIndexes:\n    \"country_pkey\" PRIMARY KEY, btree (countrycode)\nCheck constraints:\n    \"country_continent_check\" CHECK\n    (continent = 'Asia'::text OR \n      continent = 'Europe'::text OR \n      continent = 'North America'::text OR \n      continent = 'Africa'::text OR \n      continent = 'Oceania'::text OR \n      continent = 'Antarctica'::text OR \n      continent = 'South America'::text)\nForeign-key constraints:\n    \"country_capital_fkey\" \n        FOREIGN KEY (capital) \n        REFERENCES world.city(id)  \nReferenced by:\n    TABLE \"world.countrylanguage\"\n    CONSTRAINT \"countrylanguage_countrycode_fkey\" \n        FOREIGN KEY (countrycode)\n        REFERENCES country(countrycode)\n```\n\n:::\n\n:::::\n\n\n\n## Foreign keys emitted by `world.country`\n\n\n```{.sql}\nALTER TABLE world.country ADD \n    CONSTRAINT country_capital_fkey \n        FOREIGN KEY (capital)   \n        REFERENCES world.city(id);  \n\nALTER TABLE world.country \n    ADD CONSTRAINT country_fk \n        FOREIGN KEY (continent)   \n        REFERENCES world.code_continent(continent);  \n```\n\n\n\n\n# Fin {background-color=\"#1c191c\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}